 # MYSQL 업무 중 공부한 쿼리들
 - 버젼 체크 : select variables like "%version%";
 - 스토리지 엔진 체크 : show table status;
 - 스토리지 엔진 변경 : ALTER TABLE {테이블 이름} ENGINE = falcon;
 - varchar의 크기 : default 255(->65535, 버젼 5.0.3부터). 이를 넘어가는 것은 타입이 바뀐다. ex) varchar(512) -> smalltext
 - mysql table utf-8 로 세팅
		create database test DEFAULT CHARACTER SET utf8 collate utf8_general_ci;

 - timestamp 의 동작 범위, 그리고 datetime
		둘다 년-월-일 시:분:초 를 지원한다.
		mysql 및 관련 dbms 들은 timestamp 의 범위가 1970년 1월 1일 ~ 2037-12-31 이므로 값 초기화에 주의.
		범위 외의 값을 넣을 경우 0000-00-00 이 들어갈 수 있는데 이게 에러를 유발한다.
		오라클이나 play framework DB 에서는 이게 문제 없는 듯 하다.
		datetime 은 1000-01-01 부터이므로 애당초 문제 없다.
		그러나 datetime 은 current_timestamp 를 지원하지 않아 초기화에 번거롭다.
		timestamp 는 utc 시간 변환과 current_timestamp 를 지원하므로 사용이 편리할 수 있다.
		datetime 은 문자형
		timestamp 는 숫자형이 기본이다.

 - now() vs. sysdate() vs. CURRENT_TIMESTAMP
 	- 공통점: DATETIME, TIMESTAMP 타입 모두 사용 가능
 	- now(): 하나의 쿼리 단위로 동일한 값을 리턴한다. where 절에 쓸 경우 range 검색
 	- sysdate(): 함수 실행 시점의 시각을 리턴한다. where 절에 쓸 경우 full 스캔
 		- mysql server 기동 시 `--sysdate-is-now` 옵션으로 sysdate()를 now()와 동일하게 사용 가능
 	- CURRENT_TIMESTAMP(transaction_timestamp()): now()와 동일
 	- https://dba.stackexchange.com/questions/63548/difference-between-now-and-current-timestamp
		
 - auto_increment 의 동작 :
	insert 시 해당 컬럼 가장 큰 값 + 1 을 추가한다.
	중간에 delete로 빈 컬럼이 발생해도 상관 않는다.
	강제로 중복되는 값으로 auto_increment 값을 설정해도 알아서 최대값+1 로 바뀐다.
	초기화는 직전 테이블 상태를 기준으로 한다. 즉 최신 글이 137일 때 alter(137) -> delete(137) 하면 원하는 값 137은 적용되지 않는다. 결과는 138.
 - auto_increment 현재 값 알아내기
		select last_insert_id();

 - 해당 테이블 auto_increment 값 초기화하기
		alter table 테이블명 auto_increment=1;

 - 해당 테이블 프라이머리 키에 auto_increment 추가하기
alter table 테이블명 modify column 컬럼명 타입 [각종 속성, 예 : ] primary key not null default=1 auto_increment;

 - 트랜젝션 :
	어떤 작업을 수행할때 작업이 실패하더라도 이 잘못된 작업이 실질적으로 수행해야할 작업에는 영향을 미치지 않도록하는 기능이다. 
	MYSQL 스토리지 엔진 중 대표적인 2개의 경우
	MyISAM -> 속도가 빠르지만 트랜젝션 지원을 안 한다
	InnoDB -> 속도가 느리지만 트랜젝션을 지원한다
	DBD(버클리 DB) -> MyISAM 의 트랜젝션 미지원을 보완하기 위해 만들어진 트랜젝션 지원 DB 엔진
 
  - fulltext 검색 :
	like '%' 연산자를 이용한 패턴검색에 대한 대안으로, 단어 또는 구문에 대한 검색을 지원한다.
	mysql MyISAM 엔진만 지원, innoDB는 미지원
	1. 생성 : create table test (
					title text not null,
					fulltext key title(title)
					) engine=MyISAM auto_increment=1 default charset=utf8;
	2. 사용 : select title from test where match(title[, 이외 검색이 필요한 컬럼]) against('단어');
	3. 검색 단어 길이 설정 : 검색어가 너무 짧으면(기본값 : 4글자) 검색이 안 되는데 이 값을 설정하는 것 -> my.cnf 파일 -> ft_min_word_len 체크 -> 기존의 fulltext 인덱스는 삭제 후 재생성 혹은 갱신(repair table test quick;)
	4. 검색 방식 : 	자연어 검색(기본 방법, 단어 단위로 검색어 분리 후 하나라도 포함되는 행을 찾기)
					불린 모드 검색(자연어 검색 모드에서 여러 연산자를 추가 사용 가능),
					쿼리 확장 검색
	5. 참조 문서 : http://socurites.com/332
	
  - 인덱스
	select 검색을 빨리 시켜주는 테이블 -> 데이터 양이 많고 검색이 변경보다 빈번할 경우 유용 -> create 나 update 시 인뎃스 테이블도 함께 갱신하므로 부하가 생김
	1. 생성 : create table test (
					keyword varchar(20),
					index(keyword(20))
				) engine MyISAM;
	2. 기존 테이블에 추가 : alter table test add index(keyword(20));
	3. 확인 : show index from table;
	4. 삭제 : alter table test drop index keyword;
	5. 멀티(결합)인덱스 : 오라클과 달리 mysql 은 한번에 여러 컬럼을 where 조건 걸더라도 그 중 단 하나의 컬럼 인덱스만 사용하므로
					여러 인덱스를 함꼐 쓰려면 멀티 인덱싱 처리가 필요
					alter table test add index(A, B, C);
					주의사항 : 검색 순서 일치시켜야. index(A, B, C) => A->B->C 검색해야 인덱스를 탄다.
	6. 참조 기준 : order by 컬럼, where 컬럼을 따른다. 둘 다 쓰인 쿼리문에서는 where 컬럼을 따른다.
					패턴문자 검색 (like '%str%') 은 인덱스를 타지 않는다.
	7. 주의사항 :
		Index는 null 이면 안된다.
		Index를 사용할 필드의 값이 일정할 경우(성별/양력/음력 등 데이터가 일정한 경우는 효과가 크지 않음)
		Index를 사용한 필드의 조건 검색에서 연산이 이뤄질 경우( where 컬럼*10>1000 )
		Index를 사용한 필드의 조건검색이 not, <, > 일 경우(=>,<=,=,Between 은 사용이 가능하다.)
		Index를 사용한 필드의 조건검색이 like '%값'이거나 like '%값%' 일 경우 (like '값%' 은 사용가능)
		Index를 사용한 필드의 조건검색이 다른 필드와 비교일 경우 (where 컬럼1=컬럼2 ) 
		order by 인덱스컬럼1, 컬럼2 // 복수의 키에 대해서 order by를 사용한 경우
		where 컬럼1='값' order by 인덱스컬럼 // 연속하지 않은 컬럼에 대해 order by를 실행한 경우
		order by 인덱스컬럼1 desc, 인덱스컬럼2 asc // desc와 asc를 혼합하여 사용한 경우
		group by 컬럼1 order by 컬럼2 // group by와 order by의 컬럼이 다를경우
		order by abs(컬럼) // order by 절에 다른 표현을 사용할 경우
		index length 제한 : InnoDB(767 bytes), MyISAM(1000 bytes). varchar가 너무 클 땐 index 길이를 조절해준다.
							utf-8의 경우 1글자 3bytes 이고, index(name(length)) 에서 length != byte 이므로
							utf-8 인덱스의 최대값은 InnoDB 기준 767 / 3 => 약 255 라는 소리가 된다.

	8. order by의 기능 동작
		- where절에 일치하지 않는 열을 제외하고 키순서에 따라 모든 열을 읽어들인다.
		- 각각의 열에 대해 버퍼에 정렬을 위한 키와 열에 대한 포인터의 쌍을 저장한다.(이때 사용되는 버퍼의 크기는 sort_buffer_size에 결정된다.)
		- 버퍼가 가득 차면, 퀵소트를 수행하고 그 결과를 임시 파일에 보관한뒤 다시 반복한다.(sort_buffer_size의 크기에 다 담길 양이면 임시파일을 만들지 않는다.)
		- 다른 임시 파일에 대해, 최대 MERGEBUFF(기본값:7)의 영역을 하나의 블록이 될 때까지 다중 병합 작업을 수행한다. 첫번째 파일의 모든 블록이 두번째 파일과 같아질 때까지 반복한다.
		- MERGEBUFF2(기본값:15) 보다 작은 수의 블록이 남을 때 까지 반복한다.
		- 만약 order by에 대한 index를 사용하지 못할 경우는 sort_buffer_size와 read_rnd_buffer_size의 크기를 증가 시킨다.
	
	9. 커버링 인덱스
		커버링 인덱스란 원하는 데이터를 인덱스에서만 추출할 수 있는 인덱스를 의미. 일종의 쿼리 기법
		ex : select * from usertest where chgdate like '2010%' limit 100000, 100; -> select a.* from (select userno from usertest where chgdate like '2012%' limit 100000, 100) b join usertest a on b.userno = a.userno;
		
	10. fulltext 인덱스
		MyISAM 만 지원하는 인덱스 방식, 자연어 검색 및 불린 검색 등을 지원. text, varchar, binary char 타입만 사용 가능. 큰 내용의 텍스트 검색을 할 때 편리한 듯 하다.
		생성 : create table test ( ...... title text not null, FULLTEXT KEY title(title), ...) // 두 개 이상의 컬럼도 결합인덱스로 생성 가능
		수정 : alter table test add FULLTEXT(title);
		삭제 : alter table test drop index title;
		검색엔진설정 : fulltext 의 단어 검색 최소 단위 기본값은 4. 2글자 혹은 1글자 검색을 하려면 -> my.cnf 파일 -> ft_min_word_len 변경보다
		검색엔진설정 변경 후 적용, 갱신(위 검색엔진설정 변경이라든지 경우)
		  - 인덱스 삭제후 재생성
		  - REPAIR TABLE test QUICK;
		자연어 검색 : select P.title from test P where match(title) against('단어'); -> % 연산자 없이도 '단어'가 포함된 문자열을 전부 검색
				select P.gtitle, P.gdesc, match(gtitle, gdesc) against('귀여운 로고') as score from posts P where match(gtitle, gdesc) against('귀여운 로고') limit 10; -> 두 단어도 각각 분리하여 or 검색
		검색 정확도 표시 : select P.title, match(title) against('단어') as score from test P where match(title) against('단어');
		불린모드 검색 : 구문 검색(즉 그대로 검색) -> select P.title, P.desc from test P where match(title, desc) against('"귀여운 로고"' in boolean mode);
						검색어 제외 -> select P.title, P.gdesc from test P where match(title, desc) against('"귀여운 로고" -여행영상' in boolean mode);
						부분 연산자 -> select P.title, P.desc from test P where match(title, desc) against('로고*' in boolean mode); // 로고는, 로고를, 로고와 등 로고 뒤에 뭐가 붙은 것도 검색
						연산자 정리 : + -> 포함, - -> 제외, * -> 부분
	
	
  - foreign key
	InnoDB 가 지원
	쿼리 :
		create table test1 (
			code int primary key
		);
		create table test2 (
			this_code int,
			foriegn key(this_code) references test1(code) on deelete set null on update cascade
		);
	on *** cascade : 서로 연동되는 동작
	on *** set null : 해당 값에 변화가 왔을 떄  null 처리
	그런데 대형 DB에서 외래키 사용은 추가적인 무결성 점검 과정 때문에 성능 저하를 만든다는 사용자 의견이 있다.
	update, insert 시 해당 값이 foreign key로써 정당한 값인지 확인하는 과정이 포함됨. 성능 저하 수준은 모르겠음
	
	
  - count(컬럼) : 숫자 세어줌
    48만개 인덱싱 컬럼은 0.00초에 세어버림
	count() 와 limit 는 서로 호환 안 됨 : select count(*) from table limit 10; 의 결과는 48만개 (단, 리미트에 시작 숫자를 주면 0개. 작동하지 않는다. ex : limit 1, 10)
	  => 다음과 같이 수정 가능 : select count(*) from (select 1 from table limit 10) t;
	  => 의외의 장점이 될 수도 : limit 로 페이징 했어도 여전히 전체 개수를 셀 수 있다.
	
 - 면접질문의 예
  1. 디비 스키마 변경이 어려운 상황에서 새로운 기능을 추가하려면 어떻게 하는게 좋겠는가?
    -> varchar 컬럼 만들고 json 타입으로 data 받아서 처리, 대신 인덱싱은 불가
  2. 트랜젝션이 무엇인가?
    -> DB : 데이터에 대한 하나의 논리적 실행단계
    -> 스토리지 엔진 : 어떤 작업을 수행할때 작업이 실패하더라도 이 잘못된 작업이 실질적으로 수행해야할 작업에는 영향을 미치지 않도록하는 기능
  3. DB ACID?
    -> DB 트랜젝션이 안전하게 수행되는 것을 보장하는 특성 집합
    -> Atomicity (원자성) : 트랜젝션과 관련된 일들이 모두 수행되었는지? 모두 안되었는지? 보장 -> 중간단계까지 실행되고 실패하지 않음
	-> Consistency (일관성) : 트랜젝션 성공적 완료 후 언제나 일관성 있는 데이터베이스 상태로 유지하는 것
	-> Isolation (독립성) : 트랜젝션 수행 시 다른 트랜젝션의 연산 작업이 끼어들지 못하도록 보장
	  => Locking : isolation 구현 수단, 4단계가 존재
	    - lv. 1. Serializable : 무조건적 트랜젝션 일렬 수행 -> 무조건적 locking. 속도는 다소 떨어짐
		- lv. 2. Repeatable Read : 데이터를 읽는 쿼리는 쿼리에 해당되는 레코드에만 락을 지정. 이 레벨에서는 phantom read를 허용
		  ** phantom read : 한 트랜젝션에서 같은 select문을 두 번 날린 사이에 다른 트랜잭션에서 insert를 했다면 두번째 select에서는 페치된 레코드 건수가 늘어날 수 있음
		- lv. 3. Read Committed : non-repeatable read 허용.
		  ** non-repeatable read : 한 트랜잭션의 동일한 select 두 건 사이에 update가 일어났다면 읽은 값이 바뀔 수 있음
		- lv. 4. Read Uncommitted : dirty read 허용. DB들은 잘 지원하지 않음
		  ** dirty read : commit되지 않은 데이터를 읽어들임
	-> Durability (지속성) : 성공적으로 수행된 트랜젝션은 영원히 반영되어야 함
	-> InnoDB 는 지원, MyISAM은 미지원
  4. 정규화(Normalization)
	-> 관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스를 정규화라고 한다.
		- 제1정규화 : 필드에는 논리적으로 최소한의 정보만 들어있도록 한다.(테이블의 필드에 하나의 정보 단위만 들어가도록 하는 작업)
		- 제2정규화 : 기본키 필드를 중심으로 나머지 필드들은 기본키 필드에 매여 있어야 한다.
		- 제3정규화 : 한 필드의 값을 알았을 때 다른 필드의 값을 알아낼 수 없도록 서로 간에 독립적이어야 한다.
		  => 관련 예시 링크 :
		    http://blog.naver.com/sonmg?Redirect=Log&logNo=20206390439
		    http://james_parku.blog.me/110177519729
		- 데이터베이스 정규화의 장점
			1) 데이터베이스의 일관성을 향상 시킬수 있다. 
			2) 데이터베이스의 확장성을 보장 할 수 있다.
			3) 데이터베이스의 논리적 구조를 견고하게 만들 수 있다.
		- 정규화되지 않은 DB가 갖는 문제점
			나. 삭제 이상(deletion anomaly) : 한 개의 튜플을 삭제할 경우 유지해야 하는 정보까지 상실하는 정보의 손실이 일어나는 현상
			다. 삽입 이상(insertion anomaly) : 어떤 정보를 테이블에 삽입하고자 할 때 불피요한 정보까지도 삽입해야 하는 경우
			라. 갱신 이상(update anomaly) : 중복된 튜플들 중에 일부만 갱신함으로써 정보의 불일치성이 발생하게 되는 현상
		- 정규화 이론
			가. 데이터 조작에 따라 릴레이션이 가지게 되는 모순성을 피하고 보다 사용자가 원하는 형태의 릴레이션을 구성하기 위한 이론
			나. 정규형 (보다 모순성이 적어진 릴레이션)의 개념에 기반을 둔다.
			다. 어떤 릴레이션이 주어진 특정 제약조건의 집항을 만족하는지 여부에 따라 그 릴레이션이 특정 정규형에 속하는지 말할 수 있다.
			라. 정규형은 상위 단계 정규형이 하위 단계 정규형을 포함한다.
			마. 정규형의 규칙은 상위 단계로 가면서 필요한 제약 조건을 추가함으로써 좀 더 정규화된 형태의 정규형으로 정제된다.
##### OS

* OS
  * 사용자가 컴퓨터를 사용할 수 있도록 중재하고 응용 프로그램 기반 환경 제공하는, 항상 돌고 있는 프로그램
  * 하드웨어 자원 관리, 가상화
  * 메모리 관리, 가상화
  * 프로세스 관리, 스케쥴링
  * 파일 관리

* IPC(Inter Process Communication)
  * 프로세스간 통신 방법
  * 종류: FIFO, 메시지 큐, shared memory, 소켓, 세마포어, 파일
    * http://jwprogramming.tistory.com/54
    * https://kldp.org/node/65203
    * http://blog.daum.net/tlos6733/159
    * http://donkey612.blog.me/70077905415
  * 메시지 큐 vs. shared memory
    * 메시지 큐: 통신을 통한 데이터 송수신 메커니즘, 커널 경유(커널로부터 동기화 지원 받음), 시스템 콜 사용
    * 공유메모리: 데이터 공유 메커니즘, 커널 경유 없음(중개자 없음 - 가장 빠른 IPC), 시스템 콜을 사용하지 않음, 동기화 메커니즘을 사용자가 구현, file io 없이 메모리만 사용
* race condition
  * critical section(cs)
    * mutual exclusion: 프로세스 하나가 critical section 안으로 들어왔을 때 다른 어떤 놈도 안으로 들어와 실행할 수 없다.
      * 구현 방법
        * disabling interrupts: cs 시작되면 모든 인터럽트 비활성화
          * OS 안에서만 사용 가능
          * 단일 cpu만 사용 가능
          * 프로세스가 cs 종료 후 인터럽트 재활성화를 까먹으면?
        * lock variables
          * busy waiting: 무의미한 일을 하면서(프로세스/스레드는 활성화 상태) 기다리는 방법
            * 장점: 쓰레드 비활성화 상태(블로킹)가 없다, 컨텍스트 스위칭이 없다, 동기화 객체(뮤텍스, 세마포어)를 사용하지 않는다
            * 단점: cpu가 계속 일하고 있다, 시스템에 행(hang)이 걸릴 수 있다
            * 사용처: 공유 자원 권한 획득이 아주 빠른 시간 내에 이루어질 수 있다는 확신이 있는 상황, 간단한 구현이 필요한 상황
            * 예: spin lock (`while(lock != 0) { // do nothing }`)
        * strict alternation
        * peterson's solution
        * tsl
        * sleep and wakeup

* scheduling
  * 목적: fair, priority, efficiency, encourage good behavior, support heavy loads, adapt to different environments
  * non-preemptive
    * fcfs(first come first serve): 들어오는대로 순차
    * sjf(shortest job first): 짧은 것부터
    * priority scheduling: 우선tns위 값을 따로 둬서 그걸로 기준 정함, 우선순위는 유저가 조절 가능
  * preemptive: 
    * preemptive sjf: 중간에 들어온게 짧으면 지금 하는 긴 것을 일시 정지 가능, starvation problem
    * round robin: 시분할하여 프로세스를 공평 일정하게 순환
    * multi-queue: priority + round robin



---
layout: post
categories: articles
title:  "title"
excerpt: "excerpt"
tags: []
date: 2017-04-26 15:27:43
modified: 2017-04-26 15:27:43
image: 
  feature: filename
  credit: image owner
  creditlink: original link
share: true
sitemap: false
---

# 스프링 동작 구조: hello world

## 스프링 hello world 동작 원리

*http://saurus2.tistory.com/entry/Java-Spring-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91-%ED%95%98%EC%A7%80-Hello-World-%EC%9D%98-%EC%9B%90%EB%A6%AC
* 아키텍쳐 패턴: mvc 패턴
* 스프링 hello world 동작 원리
    1. 클라이언트 요청 
    2. web.xml 에서 디스패처 서블릿(Dispatcher Servlet) 클라이언트 요청을 핸들링
    3. servlet-context.xml 에서 해당 클래스의 웹요청을 처리하는 컨트롤러를 사용 [HanderMapping으로 Controller 검색]
    4. 해당 Controller 가 요청 처리 후, Home (View) 로 리턴 [뷰의 이름은 /WEB-INF/views/home.jsp 로 바뀐다.
    5. View 에 출력

## 빈 라이프 싸이클

* http://javaslave.tistory.com/48
    1. 빈 인스턴스화, DI
    2. 스프링 인지 여부 검사
    3. 빈 생성 생명주기 콜백
    4. 빈 소멸 생성주기 콜백

## DispatcherServlet

* http://hermeslog.tistory.com/156
* http://www.egovframe.org/wiki/doku.php?id=egovframework:rte:ptl:dispatcherservlet
* Spring MVC Framework의 유일한 Front Controller인 DispatcherServlet은 Spring MVC의 핵심 요소
* 웹요청 흐름
    1. client: request
    2. DispatcherServlet: doService() 준비
    3. DispatcherServlet: doDispatch() 웹요청 처리 시작
    4. DispatcherServlet: getHandler() 매핑된 컨트롤러 찾기
    5. DispatcherServlet: getInterceptors() interceptor 가져오기
    6. DispatcherServlet: preHandle() 실행될 interceptor 순차 실행
    7. DispatcherServlet: getHandler() 로 controller 인스턴스 얻기
    8. DispatcherServlet: getHandlerAdaptor() controller에 적절한 어답터 리턴
    9. DispatcherServlet: 어답터 이용해 컨트롤러 메소드 실행 (handleRequest(), invoke())
    10. DispatcherServlet: postHandle() 실행
    11. DispatcherServlet: resolveViewName() 논리적 뷰 이름을 통해 해당 view 객체 반환
    12. DispatcherServlet: render() model 객체 데이터를 보여주기 위해 실행
    13. client: response

## 빈 스코프

* 별도의 scope를 지정하지 않으면 스프링에서 default는 singleton 이다.
* singleton : 하나의 Bean 정의에 대하여 Spring IoC Container 내에 단 하나의 객체만 존재. 기본 스코프
* prototype : 하나의 Bean 정의에 대하여 다수의 객체가 존재 할 수 있다. 어플리케이션에서 요청시 (getBean()) 마다 스프링이 새 인스턴스를 생성
* request : 하나의 Bean 정의에 대하여 하나의 HTTP request의 생명주기 안에 단 하나의 객체만 존재. 즉, 각각의 HTTP Request는 자신만의 객체를 가진다. Web-aware String ApplicaiontContext 안에서만 유효하다. HTTP 요청별로 인스턴스화 되며 요청이 끝나면 소멸 (spring mvc webapplication 용도)
* session : 하나의 Bean 정의에 대해서 하나의 HTTP Session의 생명주기 안에 단 하나의 객체만 존재. Web-aware String ApplicaiontContext 안에서만 유효하다. HTTP 세션별로 인스턴스화되며 세션이 끝나며 소멸 (spring mvc webapplication 용도)
* global session : 하나의 Bean 정의에 대해서 하나의 HTTP Session의 생명주기 안에 단 하나의 객체만 존재. Web-aware String ApplicaiontContext 안에서만 유효하다. 포틀릿 기반의 웹 어플리케이션 용도. 전역 세션 스코프의 빈은 같은 스프링 MVC를 사용한 포탈 어플리케이션 내의 모든 포틀릿 사이에서 공유할 수 있다.
* thread : 새 스레드에서 요청하면 새로운 bean 인스턴스를 생성, 같은 스레드에 대해서는 항상 같은 bean 인스턴스가 반환
* custom : org.pringframework.beans.factory.config.Scope를 구현하고 커스텀 스코프를 스프링의 설정에 등록하여 사용
* 설정
    * <bean id="normalBean" class="com.java.SomeClass" scope="singleton"/>
    * @Scope("singletone")


# 자바

## ThreadLocal

* http://javacan.tistory.com/entry/ThreadLocalUsage
* 쓰레드 영역에 설정하는 변수, 쓰레드 한정 전역 변수
* since 1.2
* 용도
    * 사용자 인증정보 전파 - Spring Security에서는 ThreadLocal을 이용해서 사용자 인증 정보를 전파한다.
    * 트랜잭션 컨텍스트 전파 - 트랜잭션 매니저는 트랜잭션 컨텍스트를 전파하는 데 ThreadLocal을 사용한다.
    * 쓰레드에 안전해야 하는 데이터 보관
* 주의사항: 쓰레드 풀 환경에서 ThreadLocal을 사용하는 경우 ThreadLocal 변수에 보관된 데이터의 사용이 끝나면 반드시 해당 데이터를 삭제해 주어야 한다. 그렇지 않을 경우 재사용되는 쓰레드가 올바르지 않은 데이터를 참조할 수 있다.

## default 메소드

## LocalDate, LocalTime, LocalDateTime

* http://blog.eomdev.com/java/2016/04/01/%EC%9E%90%EB%B0%948%EC%9D%98-java.time-%ED%8C%A8%ED%82%A4%EC%A7%80.html
* 시간변환기: https://www.epochconverter.com/

## Optional

* http://javaiyagi.tistory.com/443

## Stream

## 람다

## ConcurrentMap

## foo - loop vs. Stream.forEach

* 신중하게 적용
    * primitive 타입의 경우 더 느려짐
    * 디버그 메시지가 복잡
    * 가독성에서 큰 이득이 없음


# 스프링을 돕는 도구들

## EasyMock : RESTful API Mock 서버

* https://blog.outsider.ne.kr/991

## Unitils

* 유닛, 통합테스트 도구
* http://www.unitils.org/summary.html


---
layout: post
categories: articles
title:  "title"
excerpt: "excerpt"
tags: []
date: 2017-04-26 15:27:43
modified: 2017-04-26 15:27:43
image: 
  feature: filename
  credit: image owner
  creditlink: original link
share: true
sitemap: false
---

# 스프링 동작 구조: hello world

## 스프링 hello world 동작 원리

*http://saurus2.tistory.com/entry/Java-Spring-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91-%ED%95%98%EC%A7%80-Hello-World-%EC%9D%98-%EC%9B%90%EB%A6%AC
* 아키텍쳐 패턴: mvc 패턴
* 스프링 hello world 동작 원리
    1. 클라이언트 요청 
    2. web.xml 에서 디스패처 서블릿(Dispatcher Servlet) 클라이언트 요청을 핸들링
    3. servlet-context.xml 에서 해당 클래스의 웹요청을 처리하는 컨트롤러를 사용 [HanderMapping으로 Controller 검색]
    4. 해당 Controller 가 요청 처리 후, Home (View) 로 리턴 [뷰의 이름은 /WEB-INF/views/home.jsp 로 바뀐다.
    5. View 에 출력


## DispatcherServlet

* http://hermeslog.tistory.com/156
* http://www.egovframe.org/wiki/doku.php?id=egovframework:rte:ptl:dispatcherservlet
* Spring MVC Framework의 유일한 Front Controller인 DispatcherServlet은 Spring MVC의 핵심 요소
* 웹요청 흐름
    1. client: request
    2. DispatcherServlet: doService() 준비
    3. DispatcherServlet: doDispatch() 웹요청 처리 시작
    4. DispatcherServlet: getHandler() 매핑된 컨트롤러 찾기
    5. DispatcherServlet: getInterceptors() interceptor 가져오기
    6. DispatcherServlet: preHandle() 실행될 interceptor 순차 실행
    7. DispatcherServlet: getHandler() 로 controller 인스턴스 얻기
    8. DispatcherServlet: getHandlerAdaptor() controller에 적절한 어답터 리턴
    9. DispatcherServlet: 어답터 이용해 컨트롤러 메소드 실행 (handleRequest(), invoke())
    10. DispatcherServlet: postHandle() 실행
    11. DispatcherServlet: resolveViewName() 논리적 뷰 이름을 통해 해당 view 객체 반환
    12. DispatcherServlet: render() model 객체 데이터를 보여주기 위해 실행
    13. client: response


## 빈 라이프 싸이클

* http://javaslave.tistory.com/48
    1. 빈 인스턴스화, DI
    2. 스프링 인지 여부 검사
    3. 빈 생성 생명주기 콜백
    4. 빈 소멸 생명주기 콜백


## 빈 스코프

* 별도의 scope를 지정하지 않으면 스프링에서 default는 singleton 이다.
* singleton : 하나의 Bean 정의에 대하여 Spring IoC Container 내에 단 하나의 객체만 존재. 기본 스코프
* prototype : 하나의 Bean 정의에 대하여 다수의 객체가 존재 할 수 있다. 어플리케이션에서 요청시 (getBean()) 마다 스프링이 새 인스턴스를 생성
* request : 하나의 Bean 정의에 대하여 하나의 HTTP request의 생명주기 안에 단 하나의 객체만 존재. 즉, 각각의 HTTP Request는 자신만의 객체를 가진다. Web-aware String ApplicaiontContext 안에서만 유효하다. HTTP 요청별로 인스턴스화 되며 요청이 끝나면 소멸 (spring mvc webapplication 용도)
* session : 하나의 Bean 정의에 대해서 하나의 HTTP Session의 생명주기 안에 단 하나의 객체만 존재. Web-aware String ApplicaiontContext 안에서만 유효하다. HTTP 세션별로 인스턴스화되며 세션이 끝나면 소멸 (spring mvc webapplication 용도)
* global session : 포틀릿 기반의 웹 어플리케이션 용도. 전역 세션 스코프의 빈은 같은 스프링 MVC를 사용한 포탈 어플리케이션 내의 모든 포틀릿 사이에서 공유할 수 있다.
* thread : 새 스레드에서 요청하면 새로운 bean 인스턴스를 생성, 같은 스레드에 대해서는 항상 같은 bean 인스턴스가 반환
* custom : org.pringframework.beans.factory.config.Scope를 구현하고 커스텀 스코프를 스프링의 설정에 등록하여 사용
* 설정
    * <bean id="normalBean" class="com.java.SomeClass" scope="singleton"/>
    * @Scope("singletone")
* http://javaslave.tistory.com/45


### 스프링과 싱글톤

* 스프링 싱글톤은 디자인 패턴의 싱글톤과 유사하지만 구현 방식이 다르다.
    * 스타틱 메소드, private 생성자를 쓰지 않은 평범한 클래스를 싱글톤으로 사용하게 해준다.
* 싱글톤 레지스트리: 싱글톤의 저장, 관리 == 애플리케이션 컨텍스트 == IoC 컨테이너
* 싱글톤을 쓸지 말지, 어느 범위까지 유지할지를 결정하는 다양한 스코프를 지원한다.
* 싱글톤 사용 이유: 클라이언트의 요청이 올 때마다 오브젝트를 생성하는 것은 부하가 크기 때문


# 자바

## java 메모리 관리 구조와 라이프 사이클

* text area: 기계어 프로그램 로직
* static area: static 필드 -> 로딩되면서 생성, 프로그램 종료 시 JVM에 반환
* heap area: new instance -> new 예약어로 생성, GC에 의해 반환
* stack area: scope가 있는 로컬 변수, 자동 변수, 파라미터 -> 선언 코드 라인 실행시 생성, scope 종료 시 반환
* http://dreamzelkova.tistory.com/entry/Java-12Static%EA%B3%BC-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0


## equals() & hashCode()

* 모든 자바 오브젝트가 갖고 있으며 override 가능
* 오브젝트의 동일성과 동등성을 검사
    * 동일성: 두 개의 오브젝트가 동일하다 -> 하나의 오브젝트, 두 개의 레퍼런스 변수 -> 같은 hashCode()
    * 동등성: 두 개의 서로 다른 오브젝트 -> 서로 다른 메모리상에 존재 -> 정보가 동등 -> equals() 검사 결과가 true
* 사용자 클래스가 프로그래머가 의도한 동일성, 동등성 검사를 통과할 수 있도록 2개를 오버라이드 구현
    * 특히 Map, Set, List 등 컬렉션 자료구조를 사용할 경우, 내부적인 중복 검사에서 객체의 동등성 비교를 위해 equals() 뿐만 아니라 hashCode()를 호출하므로 주의하여 함께 구현해줘야 한다.
    * 또한 Map은 put() 순간 들어오는 오브젝트의 hashCode()를 기억하므로, 들어온 오브젝트 값이 변경된 뒤의 hashCode()는 인식하지 못한다. 즉 mutable한 데이터를 집어넣으면 데이터 비교 결과를 보장할 수 없다.
* equals() 규약
    * Reflexive(재귀성) : 오브젝트는 자기자신과 같아야 한다.
    * Symmetric(대칭성) : `a.equals(b)`가 참이면 `b.equals(a)`도 참이어야 한다.
    * Transitive(추이성) : `a.equals(b)`와 `b.equals(c)`가 참이면 `c.equals(a)`도 참이어야 한다.
    * Consistent(일관성) : `equals()` 메소드를 여러 번 호출해도 프로퍼티가 변경되기 전에는 결과가 일정하게 같아야 한다. 즉 두 오브젝트가 같다면 프로퍼티를 바꾸지 않는 한 계속 같은 상태로 남는다.
    * Null comparison(Null 비교) : 어떤 오브젝트든 `null`과의 비교 결과는 `false`이며, NPE(NullPointerException)를 발생시키면 안된다. 예를 들어 `a.equals(null)`는 `false`이고, `null`을 포함해서 모르는 오브젝트를 `equals()`에 인자로 넘기는 것은 java에서 NPE를 피하는 좋은 코딩 습관(practice)이다.
* hashCode() 규약
    * `equals()`로 비교시 두개의 오브젝트가 같다면, `hashCode()` 값도 같아야 한다.
    * `equals()` 로 비교시 `false`라면, `hashCode()` 값은 다를수도, 같을수도 있다. 그러나 성능을 위해서는 `hashCode()` 값이 다른것이 낫다. 그래야 해싱 알고리즘으로 Set 에 해당 오브젝트가 존재하는지 아닌지 빠르게 검색할 수 있다.
    * `hashCode()` 값이 같다고 해서, `equals()`가 true 를 리턴하는 것은 아니다. 해싱 알고리즘 자체의 문제로, 같은 해시값이 나올 수 있다.
* http://anster.tistory.com/160


## ThreadLocal

* 쓰레드 영역에 설정하는 변수, 쓰레드 한정 전역 변수
* since 1.2
* private static field 생성 > set() > get() > remove()
* 용도n
    * 사용자 인증정보 전파 - Spring Security에서는 ThreadLocal을 이용해서 사용자 인증 정보를 전파한다.
    * 트랜잭션 컨텍스트 전파 - 트랜잭션 매니저는 트랜잭션 컨텍스트를 전파하는 데 ThreadLocal을 사용한다.
    * 쓰레드에 안전해야 하는 데이터 보관
* 주의사항: 쓰레드 풀 환경에서 ThreadLocal을 사용하는 경우 ThreadLocal 변수에 보관된 데이터의 사용이 끝나면 반드시 해당 데이터를 삭제해 주어야 한다. 그렇지 않을 경우 재사용되는 쓰레드가 올바르지 않은 데이터를 참조할 수 있다.
* http://javacan.tistory.com/entry/ThreadLocalUsage


## java 8 새로운 기능들

* 자바 8의 큰 변경점을 잘 요약한 글: http://blog.takipi.com/5-features-in-java-8-that-will-change-how-you-code/
    1. 람다식
    2. 병렬 작업
    3. 나즈혼(Nashorn) 엔진 = java + js
    4. 새로운 시간 / 날짜 API
    5. 동시성 가산기


### default 메소드 (interface 메소드 함께 정리)

* interface 메소드만 가질 수 있음
* 인터페이스가 가질 수 있는 메소드 구현체
* 만든 이유: 새로운 람다식 기능, 기존 java 7 인터페이스 코드와 구현체를 깨뜨리지 않으면서 기능을 넣어야 했다.
* interface vs abstract class
    * 인터페이스는 클래스가 아니다 -> 다중 상속 가능,
    * 인터페이스는 모든 멤버 메소드가 구현 대상
* java 8 interface 메소드
    * public abstract: 기본값, 생략 가능
    * default: 인터페이스에서 구현하는 메소드
    * static
        * default와 비슷하나 차이점은 구현체에서 이것을 override할 수 없다.
        * 인스턴스에서 사용 불가.
        * 인스턴스 없이 인터페이스명으로 접근 가능 (ex: Interface.staticMethod();)


### 람다식, 함수형 인터페이스

* 함수형 인터페이스(functional interface): 오로지 하나의 public abstract 메소드를 갖는 인터페이스
    * 람다식을 사용할 수 있게 해준다.
    * 컴파일러는 람다식을 자동으로 익명클래스로 바꾸어, 특정 인터페이스의 구현 객체를 마치 인자를 넘기듯 전달
    * ex: Comparator, Observer, Callable, java.util.function 패키지 내부의 인터페이스들
* @FunctionalInterface: 인터페이스에 functional interface 제약 조건을 걸어주는 어노테이션


### LocalDate, LocalTime, LocalDateTime

* Date, Calendar 클래스를 대체
    * 기존 문제점
        * 불변 객체가 아니므로, VO가 별칭 문제, 스레드 불안정성 등의 문제에서 자유롭지 못함
        * int 상수 필드를 남용
        * 헷갈리는 월 지정
        * 일관성 없는 요일 상수
        * Date와 Calendar의 불편한 역할 분담: Date의 연산 기능은 deprecated, 날짜간 연산과 국제화 지원을 Calendar가 담당
        * 오류에 둔감한 GMT 시간대 ID 지정
* 이제 JodaTime 쓸 필요 없음
* java.time 패키지
* http://blog.eomdev.com/java/2016/04/01/%EC%9E%90%EB%B0%948%EC%9D%98-java.time-%ED%8C%A8%ED%82%A4%EC%A7%80.html
* http://d2.naver.com/helloworld/645609
* 웹 시간변환기 참고: https://www.epochconverter.com/


### Optional

* null safe한 코딩을 위해 등장
* 주로 메소드 파라미터를 감싸는 wrapper로 사용
* 값이 없을 경우 적절한 기본값을 주거나 NPE를 발생시키도록 선택 가능
* http://javaiyagi.tistory.com/443


### Stream

* 람다식의 효과적인 사용을 촉진하도록 만든 람다 API 중 하나
* Collection을 다루는 새로운 방법을 제공
* 파이프식 처리, 고차함수로 구조의 추상화
* 지연 연산, 병렬 처리 등이 동일 인터페이스로 제공됨

#### for - loop vs. Stream.forEach

* 신중하게 적용
    * primitive 타입의 경우 더 느려짐
    * 디버그 메시지가 복잡
    * 가독성에서 큰 이득이 없음


### ConcurrentMap에 새로운 기능(람다 메소드) 추가

* ConcurrentMap 자체는 java 5 부터 있어왔음: 쓰레드 세이프하고 원자성 보장하는 Map
* 람다, 스트림 방식 추가
* computeIfAbsent(), putIfAbsent(), getOrDefault(), replace() 등 추가
* remove()는 이제 키만 검사하지 않고 키 밸류를 모두 검사 가능


# 스프링을 돕는 도구들

## EasyMock : RESTful API Mock 서버

* https://blog.outsider.ne.kr/991


## Unitils

* 유닛, 통합테스트 도구
* http://www.unitils.org/summary.html


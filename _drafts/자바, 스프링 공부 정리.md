---
layout: post
categories: articles
title:  "title"
excerpt: "excerpt"
date: 2017-04-26 15:27:43
modified: 2017-07-27 16:56:34
share: false
sitemap: false
---

# 스프링


## 스프링 동작 구조: hello world 동작 원리

*http://saurus2.tistory.com/entry/Java-Spring-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91-%ED%95%98%EC%A7%80-Hello-World-%EC%9D%98-%EC%9B%90%EB%A6%AC
* 아키텍쳐 패턴: mvc 패턴
* 스프링 hello world 동작 원리
    1. 클라이언트 요청 
    2. web.xml 에서 디스패처 서블릿(Dispatcher Servlet) 클라이언트 요청을 핸들링
    3. servlet-context.xml 에서 해당 클래스의 웹요청을 처리하는 컨트롤러를 사용 [HanderMapping으로 Controller 검색]
    4. 해당 Controller 가 요청 처리 후, Home (View) 로 리턴 [뷰의 이름은 /WEB-INF/views/home.jsp 로 바뀐다.
    5. View 에 출력


## DispatcherServlet

* http://hermeslog.tistory.com/156
* http://www.egovframe.org/wiki/doku.php?id=egovframework:rte:ptl:dispatcherservlet
* http://openeg.co.kr/483
* Spring MVC Framework의 유일한 Front Controller인 DispatcherServlet은 Spring MVC의 핵심 요소
* 웹요청 흐름 (request lifecycle)
    1. client: request
    2. Filter
    2. DispatcherServlet: doService() 준비
    3. DispatcherServlet: doDispatch() 웹요청 처리 시작
    4. DispatcherServlet: getHandler() 매핑된 컨트롤러 찾기
    5. DispatcherServlet: getInterceptors() interceptor 가져오기
    6. DispatcherServlet: preHandle() 실행될 interceptor 순차 실행
    7. DispatcherServlet: getHandler() 로 controller 인스턴스 얻기
    8. DispatcherServlet: getHandlerAdaptor() controller에 적절한 어답터 리턴
    9. DispatcherServlet: 어답터 이용해 컨트롤러 메소드 실행 (handleRequest(), invoke())
    10. DispatcherServlet: postHandle() 실행
    11. DispatcherServlet: resolveViewName() 논리적 뷰 이름을 통해 해당 view 객체 반환
    12. DispatcherServlet: render() model 객체 데이터를 보여주기 위해 실행
    13. Filter
    13. client: response


## Interceptor

* http://addio3305.tistory.com/43
* 정확한 명칭: Handler Interceptor
* client request를 받은 dispatcherServlet과 controller 사이의 요청/응답을 가공
* 예: 로그인 기능, 특정 페이지 접속할 때 로그인 되었을 경우만 페이지를 보여주기
  * as-is: 모든 페이지에 로그인 체크 로직을 ctrl+c, ctrl+v
  * to-be: 인터셉터에서 한 번만 구현 - 모든 페이지(컨트롤러) 요청에서 인터셉터가 로그인 체크
* 기본: `public class Interceptor extends HandlerInterceptorAdapter { @Override public boolean preHandle() {} @Override public boolean postHandle() {} }`


## 빈 라이프 싸이클

* http://javaslave.tistory.com/48
  1. 빈 인스턴스화, DI: xml이나 어노테이션으로 빈 스캔, 빈 인스턴스 생성, 빈 프로퍼티에 의존성 주입
  2. 스프링 인지 여부 검사: 빈이 `BeanNameAware` 인터페이스 구현 시 `setBeanName()` 호출, `BeanClassLoaderAware` 인터페이스 구현 시 `setBeanClassLoader()` 호출, `ApplicationContextAware` 인터페이스 구현 시 `setApplicationContext()` 호출
  3. 빈 생성 생명주기 콜백: `@PostConstruct` 어노테이션 적용 메소드 호출 등
  4. 빈 소멸 생명주기 콜백: `@PreDestroy` 어노테이션 적용 메소드 호출


## 빈 스코프

* 별도의 scope를 지정하지 않으면 스프링에서 default는 singleton 이다.
* singleton : 하나의 Bean 정의에 대하여 Spring IoC Container 내에 단 하나의 객체만 존재. 기본 스코프
* prototype : 하나의 Bean 정의에 대하여 다수의 객체가 존재 할 수 있다. 어플리케이션에서 요청시 (getBean()) 마다 스프링이 새 인스턴스를 생성
* request : 하나의 Bean 정의에 대하여 하나의 HTTP request의 생명주기 안에 단 하나의 객체만 존재. 즉, 각각의 HTTP Request는 자신만의 객체를 가진다. Web-aware String ApplicaiontContext 안에서만 유효하다. HTTP 요청별로 인스턴스화 되며 요청이 끝나면 소멸 (spring mvc webapplication 용도)
* session : 하나의 Bean 정의에 대해서 하나의 HTTP Session의 생명주기 안에 단 하나의 객체만 존재. Web-aware String ApplicaiontContext 안에서만 유효하다. HTTP 세션별로 인스턴스화되며 세션이 끝나면 소멸 (spring mvc webapplication 용도)
* global session : 포틀릿 기반의 웹 어플리케이션 용도. 전역 세션 스코프의 빈은 같은 스프링 MVC를 사용한 포탈 어플리케이션 내의 모든 포틀릿 사이에서 공유할 수 있다.
* thread : 새 스레드에서 요청하면 새로운 bean 인스턴스를 생성, 같은 스레드에 대해서는 항상 같은 bean 인스턴스가 반환
* custom : org.pringframework.beans.factory.config.Scope를 구현하고 커스텀 스코프를 스프링의 설정에 등록하여 사용
* 설정
    * <bean id="normalBean" class="com.java.SomeClass" scope="singleton"/>
    * @Scope("singletone")
* http://javaslave.tistory.com/45


### 스프링과 싱글톤

* 스프링 싱글톤은 디자인 패턴의 싱글톤과 유사하지만 구현 방식이 다르다.
    * 스타틱 메소드, private 생성자를 쓰지 않은 평범한 클래스를 싱글톤으로 사용하게 해준다.
* 싱글톤 레지스트리: 싱글톤의 저장, 관리 == 애플리케이션 컨텍스트 == IoC 컨테이너
* 싱글톤을 쓸지 말지, 어느 범위까지 유지할지를 결정하는 다양한 스코프를 지원한다.
* 싱글톤 사용 이유: 클라이언트의 요청이 올 때마다 오브젝트를 생성하는 것은 부하가 크기 때문


## DIP, IoC, DI

* IoC(Inversion of Control): 가장 큰 개념
  * 전통적인 방식에 반대되는 흐름으로 코드가 진행되는 것을 말하는 일반적인 용어
  * 라이브러리 vs. 프레임워크, "라이브러리와 프레임워크의 관계는 IoC를 설명하는 단골 예입니다. 라이브러리를 사용할 때는 내 코드가 라이브러리 코드(외부 코드)를 호출하지만 프레임워크를 사용할 때는 프레임워크(외부 코드)가 내 코드를 호출합니다."
  * == Hollywood Principle, "Don’t call us, we’ll call you.(합격했는지 귀찮게 자꾸 전화하지마. 합격하면 우리가 너한테 연락할꺼야.)"
    * http://wiki.c2.com/?HollywoodPrinciple
  * "IoC는 너무 일반적인 용어라서 사람들이 혼동한다. 여러 IoC 주창자들과의 많은 토론 끝에 우리는 Dependency Injection(의존성 주입, 이하 DI)이란 이름에 다다랐다."
  * "IoC는 프레임워크의 일반적인 특성이기 때문에, Spring과 같은 컨테이너가 IoC를 사용하기 때문에 특별하다고 말하는 것은 내 차는 바퀴를 가졌기 때문에 특별하다고 말하는 것과 같다."
    * http://www.martinfowler.com/articles/injection.html#InversionOfControl
  * IoC Container: Dependency Inversion Principle이 적용된 모듈의 조립을 도와주는 도구
    * DIP를 하기 위해 반드시 필요한 것은 아님
    * 모듈 조립 + 모듈 개체의 수명 관리 기능 제공
    * 스프링 `applicationContext.xml`
  * 이규원, IoC: https://justhackem.wordpress.com/2016/05/14/inversion-of-control/
* DIP(Dependency Inversion Principle)
  * 의존관계를 갖는 모듈 인스턴스의 구성이 추상화에 의존하는 것
* Dependency Injection
  * DIP 구현 기법 중 하나
  * 종류
    1. Constructor Injection: 가장 많이 사용되는 방법
      * `public Class(DIModule instance) { this.instance = instance; }`
    2. Property Injection
    3. Interface Injection
  * Service Locator:  Dependency Injection과는 다른 Dependency Inversion Principle 적용법
    * 의존성이 필요한 시점에 능동적으로 의존성 해결을 Service Locator에 요청
    * 의존자 모듈이 매개변수를 가지지 않는 기본 생성자를 통해 생성되어야 하는 제약조건이 있는 경우나 의존성 모듈이 준비되기 전에 의존자 모듈 인스턴스가 만들어져야 하는 경우 등에 사용 가능
    * https://yangbongsoo.gitbooks.io/study/content/ac1d_ccb4_c9c0_d5a5_acfc_b514_c790_c778_d328_d134.html
    * **안티패턴**
      * http://www.haruair.com/blog/3880
      * http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/
* 이규원, DIP 관련 용어 정리: https://justhackem.wordpress.com/2016/05/13/dependency-inversion-terms/


## 로깅 (// TODO)

* 현업 스프링에서 가장 보편적인 로깅 방식: 각 서비스 빈의 필드에 `private static final Logger logger = LoggerFactory.getLogger(Class.class);`
* 토비 스프링의 이일민 님, CTO 이규원님: static 로거는 강결합이고 테스트를 어렵게 하므로 좋지 않다
* 대안1: `private final Logger logger = LoggerFactory.getLogger();`
* 대안2: 스프링 주입 `@Autowired`
  * 이일민 님, 이규원 님은 어노테이션을 쓰지 않은 명시적 코딩이 더 낫다고 주장
* https://stackoverflow.com/questions/26517309/how-do-i-inject-a-logger-into-a-field-in-the-sample-spring-boot-application
* https://stackoverflow.com/questions/16464496/can-i-autowire-named-loggers
* https://stackoverflow.com/questions/6351082/using-java-annotation-to-inject-logger-dependency


## ReflectionUtils, ReflectionTestUtils

* 리플렉션을 쉽게 사용할 수 있게 해주는 스프링 유틸리티 클래스
* 테스트에서 private 필드에 접근하는 등의 경우에 좋은 대안을 제공한다.
* http://namocom.tistory.com/403
 

## 스프링 사용 중 트러블 슈팅

### [SetPropertiesRule]{Server/Service/Engine/Host/Context} Setting property 'source' to 'org.eclipse.jst.jee.server:Example' did not find a matching property.

* Tomcat 6.0.16부터 source라는 프로퍼티가 추가되었는데 WTP가 source라는 속성을 프로젝트의 context에 추가해서 발생하는 것
* 떠도 영향 없음, 자세한 영향은 조사하지 않음
* 해결: Server Options > Publish module contexts to separate XML files 체크
* https://blog.outsider.ne.kr/559
* https://stackoverflow.com/questions/104854/setpropertiesrule-warning-message-when-starting-tomcat-from-eclipse

### Spring Security  디펜던시 삽십이 주의사항

* 접근에 인증 절차가 자동으로 걸림

### properties에 profile 적용하기

* http://jsonobject.tistory.com/220


## Anotation

### Mock 테스트 할 때, @WebMvcMock vs. @SpringBootTest

* 차이 요약: slicing, 테스트 레이어 범위
* @SpringBootTest: the general test annotation. If you're looking for something that does the same thing prior to 1.4, that's the one you should use. It does not use slicing at all which means it'll start your full application context and not customize component scanning at all.
* @WebMvcTest: only goes to scan the controller you've defined and the MVC infrastructure. That's it. So if your controller has some dependency to other beans from your service layer, the test won't start until you either load that config yourself or provide a mock for it. This is much faster as we only load a tiny portion of your app. This annotation uses slicing.
* https://stackoverflow.com/questions/39865596/difference-between-using-mockmvc-with-springboottest-and-using-webmvctest


# 자바


## 싱글톤(singleton)의 구현

* eager initialization: `private static Class instance = new Class();`, `private Class() {}`, `public static Class getInstance() { return instance; }`
* static block initialization: `static { instance = new Class(); }`
* lazy initialization: `public static Class getInstance() { if (instance == null) { instance = new Class(); } return instance; }`
* thread safe initialization
* **initialization on demand holder idiom**
* https://blog.seotory.com/post/2016/03/java-singleton-pattern


## java 메모리 관리 구조와 라이프 사이클

* text area: 기계어 프로그램 로직
* static(data) area: static 필드 -> 클래스 필드, class loader가 클래스를 로드하면서 생성, 프로그램 종료 시 JVM에 반환
* heap area: new instance -> 인스턴스 필드, new 예약어로 생성, GC에 의해 반환
* stack area: scope가 있는 로컬 변수, 자동 변수, 파라미터 -> 선언 코드 라인 실행시 생성, scope 종료 시 반환
* http://dreamzelkova.tistory.com/entry/Java-12Static과-메모리-구조


## java 클래스 멤버 변수 초기화 순서

1. static 변수
  * 메모리: method area(class area, static area)
  * 제일 먼저 초기화
2. 필드 변수
  * 메모리: heap area
3. 생성자 block
  * JVM이 내부적으로 locking (thread safe)
  * final 필드의 다시화는 생성자 block이 끝난 다음
  * 이미 초기화된 필드 변수는 덮어씀
* http://eyevsky.tistory.com/entry/Java-클래스-멤버-변수들의-초기화-순서

## java class loader

* 런타임 시점에 클래스를 동적으로 로딩할 수 있게 해주는 기술
  * ex) `Class A = new HelloWorld();` -> 코드 최초 실행 시 JVM이 `HelloWorld` 클래스를 클래스 로더를 통해 메모리 로드
* 기술적 특징
  * 계층적: 클래스 로더간 계층 구조를 가짐, 최상위 클래스 로더는 부트스트랩 클래스 로더
  * 위임형 로드 요청(Delegate Load Request): 상위 클래스 로더가 로딩한 클래스가 우선권을 가짐.
    * 하위 로더가 클래스 로딩을 하게 되면 상위에 위임, 위임은 최상위까지 타고 올라감
    * ex) CL1 - CL2 - CL3 클래스로더 구조라면, 최하위 CL3가 하는 클래스 로딩은 CL2에 위임을 거쳐 CL1이 위임 받아서 하게 됨
    * 특정 위치의 클래스 로더가 클래스 로드를 요청받으면, 상위 클래스 로더에 이미 로딩된 것인지 거슬러 올라가며 확인 -> 부트스트랩까지 가도 없으면 자신이 직업 파일 시스템에서 해당 클래스를 찾음
  * 
* 구조
  * User defined CL( -> User defined CL) -> system CL -> extension CL -> bootstrap CL
  * bootstrap CL: `$JAVA_HOME$/jre/lib/rt.jar`, JVM 실행 시 가장 먼저 실행, 자바 실행에 필요한 기본 클래스들 로드, 다른 클래스 로더와 달리 자바가 아니라 네이티브 코드로 구현되어 있음
  * extension CL: `$JAVA_HOME$/jre/lib/ext/*.jar`, 자바 확장 클래스들(보안 확장 기능 등), 별도로 `$CLASSPATH$`에 설정되어 있지 않아도 로드
  * system CL: `$CLASSPATH$`, 사용자가 패쓰에 지정한 애플리케이션의 클래스 로드
  * user defined CL: 사용자가 코드 상에서 생성해서 사용하는 로더
* 웹로직 클래스 로더
  * user defined CL
  * 종류
    * EJB-JAR
      * EJB를 JAR 형식으로 배포할 때, 각 JAR마다 생성
      * 따라서 JAR 간 클래스 참조 불가
      * 참조가 필요하다면(ex: 다른 EJB의 remote interface, home interface 등) 동일한 JAR에 패키징
    * WAR
      * JSP, 서블릿을 로딩하는 클래스 로더
      * `WEB-INF/classes`, `WEB-INF/lib` 디렉토리의 클래스 로딩 우선순위를 상위 클래스보다 우선하도록 변경 가능 -> 웹로직 관리 웹콘솔에서 `PreferWebInfClasses -> true`
    * EAR
      * EAR 로딩 클래스
* http://blueyikim.tistory.com/37


## equals() & hashCode() : 자바 오브젝트 동일성과 동등성

* 모든 자바 오브젝트가 갖고 있으며 override 가능
* 오브젝트의 동일성과 동등성을 검사
    * 동일성: 두 개의 오브젝트가 동일하다 -> 하나의 오브젝트, 두 개의 레퍼런스 변수 -> 같은 hashCode()
    * 동등성: 두 개의 서로 다른 오브젝트 -> 서로 다른 메모리상에 존재 -> 정보가 동등 -> equals() 검사 결과가 true
* 사용자 클래스가 프로그래머가 의도한 동일성, 동등성 검사를 통과할 수 있도록 2개를 오버라이드 구현
    * 특히 Map, Set, List 등 컬렉션 자료구조를 사용할 경우, 내부적인 중복 검사에서 객체의 동등성 비교를 위해 equals() 뿐만 아니라 hashCode()를 호출하므로 주의하여 함께 구현해줘야 한다.
    * 또한 Map은 put() 순간 들어오는 오브젝트의 hashCode()를 기억하므로, 들어온 오브젝트 값이 변경된 뒤의 hashCode()는 인식하지 못한다. 즉 mutable한 데이터를 집어넣으면 데이터 비교 결과를 보장할 수 없다.
* equals() 규약
    * Reflexive(재귀성) : 오브젝트는 자기자신과 같아야 한다.
    * Symmetric(대칭성) : `a.equals(b)`가 참이면 `b.equals(a)`도 참이어야 한다.
    * Transitive(추이성) : `a.equals(b)`와 `b.equals(c)`가 참이면 `c.equals(a)`도 참이어야 한다.
    * Consistent(일관성) : `equals()` 메소드를 여러 번 호출해도 프로퍼티가 변경되기 전에는 결과가 일정하게 같아야 한다. 즉 두 오브젝트가 같다면 프로퍼티를 바꾸지 않는 한 계속 같은 상태로 남는다.
    * Null comparison(Null 비교) : 어떤 오브젝트든 `null`과의 비교 결과는 `false`이며, NPE(NullPointerException)를 발생시키면 안된다. 예를 들어 `a.equals(null)`는 `false`이고, `null`을 포함해서 모르는 오브젝트를 `equals()`에 인자로 넘기는 것은 java에서 NPE를 피하는 좋은 코딩 습관(practice)이다.
* hashCode() 규약
    * `equals()`로 비교시 두개의 오브젝트가 같다면, `hashCode()` 값도 같아야 한다.
    * `equals()` 로 비교시 `false`라면, `hashCode()` 값은 다를수도, 같을수도 있다. 그러나 성능을 위해서는 `hashCode()` 값이 다른것이 낫다. 그래야 해싱 알고리즘으로 Set 에 해당 오브젝트가 존재하는지 아닌지 빠르게 검색할 수 있다.
    * `hashCode()` 값이 같다고 해서, `equals()`가 true 를 리턴하는 것은 아니다. 해싱 알고리즘 자체의 문제로, 같은 해시값이 나올 수 있다.
* http://anster.tistory.com/160


## ThreadLocal

* 쓰레드 영역에 설정하는 변수, 쓰레드 한정 전역 변수
* since 1.2
* private static field 생성 > set() > get() > remove()
* 용도n
    * 사용자 인증정보 전파 - Spring Security에서는 ThreadLocal을 이용해서 사용자 인증 정보를 전파한다.
    * 트랜잭션 컨텍스트 전파 - 트랜잭션 매니저는 트랜잭션 컨텍스트를 전파하는 데 ThreadLocal을 사용한다.
    * 쓰레드에 안전해야 하는 데이터 보관
* 주의사항: 쓰레드 풀 환경에서 ThreadLocal을 사용하는 경우 ThreadLocal 변수에 보관된 데이터의 사용이 끝나면 반드시 해당 데이터를 삭제해 주어야 한다. 그렇지 않을 경우 재사용되는 쓰레드가 올바르지 않은 데이터를 참조할 수 있다.
* http://javacan.tistory.com/entry/ThreadLocalUsage


## java 8 새로운 기능들

* 자바 8의 큰 변경점을 잘 요약한 글: http://blog.takipi.com/5-features-in-java-8-that-will-change-how-you-code/
    1. 람다식
    2. 병렬 작업
    3. 나즈혼(Nashorn) 엔진 = java + js
    4. 새로운 시간 / 날짜 API
    5. 동시성 가산기


### default 메소드 (interface 메소드 함께 정리)

* interface 메소드만 가질 수 있음
* 인터페이스가 가질 수 있는 메소드 구현체
* 만든 이유: 새로운 람다식 기능, 기존 java 7 인터페이스 코드와 구현체를 깨뜨리지 않으면서 기능을 넣어야 했다.
* interface vs abstract class
    * 인터페이스는 클래스가 아니다 -> 다중 상속 가능,
    * 인터페이스는 모든 멤버 메소드가 구현 대상
* java 8 interface 메소드
    * public abstract: 기본값, 생략 가능
    * default: 인터페이스에서 구현하는 메소드
    * static
        * default와 비슷하나 차이점은 구현체에서 이것을 override할 수 없다.
        * 인스턴스에서 사용 불가.
        * 인스턴스 없이 인터페이스명으로 접근 가능 (ex: Interface.staticMethod();)


### 람다식, 함수형 인터페이스

* 함수형 인터페이스(functional interface): 오로지 하나의 public abstract 메소드를 갖는 인터페이스
    * 람다식을 사용할 수 있게 해준다.
    * 컴파일러는 람다식을 자동으로 익명클래스로 바꾸어, 특정 인터페이스의 구현 객체를 마치 인자를 넘기듯 전달
    * ex: Comparator, Observer, Callable, java.util.function 패키지 내부의 인터페이스들
* @FunctionalInterface: 인터페이스에 functional interface 제약 조건을 걸어주는 어노테이션


### LocalDate, LocalTime, LocalDateTime

* Date, Calendar 클래스를 대체
    * 기존 문제점
        * 불변 객체가 아니므로, VO가 별칭 문제, 스레드 불안정성 등의 문제에서 자유롭지 못함
        * int 상수 필드를 남용
        * 헷갈리는 월 지정
        * 일관성 없는 요일 상수
        * Date와 Calendar의 불편한 역할 분담: Date의 연산 기능은 deprecated, 날짜간 연산과 국제화 지원을 Calendar가 담당
        * 오류에 둔감한 GMT 시간대 ID 지정
* 이제 JodaTime 쓸 필요 없음
* java.time 패키지
* http://blog.eomdev.com/java/2016/04/01/%EC%9E%90%EB%B0%948%EC%9D%98-java.time-%ED%8C%A8%ED%82%A4%EC%A7%80.html
* http://d2.naver.com/helloworld/645609
* 웹 시간변환기 참고: https://www.epochconverter.com/


### Optional

* null safe한 코딩을 위해 등장
* 주로 메소드 파라미터를 감싸는 wrapper로 사용
* 값이 없을 경우 적절한 기본값을 주거나 NPE를 발생시키도록 선택 가능
* http://javaiyagi.tistory.com/443


### Stream

* 람다식의 효과적인 사용을 촉진하도록 만든 람다 API 중 하나
* Collection을 다루는 새로운 방법을 제공
* 파이프식 처리, 고차함수로 구조의 추상화
* 지연 연산, 병렬 처리 등이 동일 인터페이스로 제공됨

#### for - loop vs. Stream.forEach

* 신중하게 적용
    * primitive 타입의 경우 더 느려짐
    * 디버그 메시지가 복잡
    * 가독성에서 큰 이득이 없음


### ConcurrentMap에 새로운 기능(람다 메소드) 추가

* ConcurrentMap 자체는 java 5 부터 있어왔음: 쓰레드 세이프하고 원자성 보장하는 Map
* 람다, 스트림 방식 추가
* computeIfAbsent(), putIfAbsent(), getOrDefault(), replace() 등 추가
* remove()는 이제 키만 검사하지 않고 키 밸류를 모두 검사 가능


## 테스트 프레임워크, 로그의 파사드 주입, final static 로그, 로그 테스트

* 로그 구현체: log4j -> logback -> log4j2
* 파사트: apache commons logging -> slf4j
* 결론: slf4j + log4j2
* 로그 구현체의 선언
  * as-is: `private static final Logger logger = LoggerFactory.getLogger(Class.class);`
    * 토비, 이일민
      * "Logger를 static으로 정의하지 않아야 한다는 건 이미 15년 전에 결론이 난 얘기다. JVM이 날라다녀서, 한 때 유행했던 오브젝트 풀을 쓰는 게 매번 인스턴스 생성하는 것보다 더 느린 세상이 된지 언제인데."
      * "싱글톤이 필요하면 static으로 만들지 말고 IoC 컨테이너의 싱글톤 레지스트리에게 인스턴스를 맡기면 충분"
      * "로깅은 JCL이나 SLF4J와 같은 로깅 프레임워크 퍼사드를 이용한 배포시점 의존성 바인딩을 이용하는 방식이 사실상의 표준"
      * "스코프만 볼 때, 인스턴스마다 다르게 로거를 지정할 이유가 거의 없으니 클래스 스코프가 나을 수도 있다: `static` 사용"
      * "스태틱 변수로 정의한 로거는 상속을 했을 때 매번 재정의 하지 않으면 상위 로거를 공유해야 할텐데 스태틱 초기화 단계에서 로거 이름을 지정해야 하니 상위 클래스 이름 밖에 못 준다. 이걸 멤버 인스턴스 필드로 선언하면 `getClass()`를 가지고 동적으로 이름을 가져올 수 있으니 로거의 이름을 해당 인스턴스의 클래스로 지정하기에 유리"
      * "초기 로깅 프레임워크에는 지금은 고쳐진 스태틱 로거-메모리 누수 문제가 있어 워낙 강한 경고를 많이 받기도"
      * "굳이 특별한 이유가 없음에도 `static`을 남발하는 습관도 문제"
      * "`static`이니 로거의 동작을 테스트 할 수 없고, 할 필요도 없다고 믿는 경우도 존재"
      * "단위 테스트 때 mock이나 fake object를 지정하는 것이 불가"
      * https://www.facebook.com/tobyilee/posts/10210853744514228
    * 이규원
      * "`private static final Dependency dependency;` 코드는 2가지를 의미한다."
        * "프로세스 수준에서 공유되는 의존모듈 인스턴스가 존재한다."
        * "코드는 특정 의존 모듈 혹은 인프라에 명시적으로 종속된다."
      * https://www.facebook.com/gyuwon.yi/posts/1467051656671386
      * "싱글턴은 정적이지 않다", https://justhackem.wordpress.com/2017/07/05/singleton-is-not-static/
  * to-be
    * `proteced(private) final Logger logger = LoggerFactory.getLogger(Class.class);`
    * 스프링 코어 소스에 두 종류가 다 들어있는 경우: https://github.com/spring-projects/spring-framework/blob/master/spring-websocket/src/main/java/org/springframework/web/socket/sockjs/transport/session/AbstractSockJsSession.java#L90
    * **FINAL**: 로거를 prototype scope 빈으로 등록하고, `InjectionPoint`를 파라미터로 이용해 클래스명을 지정 후, 사용 클래스에서 생성자로 주입한다.
      * https://dzone.com/articles/logger-injection-with-springs-injectionpoint
      * `InjectionPoint`: 스프링 4.3부터 추가, https://moelholm.com/2016/10/09/spring-4-3-introducing-the-injectionpoint/
* slf4j의 테스트: http://projects.lidalia.org.uk/slf4j-test/
* 롬복(lombok)의 `@Slf4j` 어노테이션은 `private static final`을 사용하는데, 이를 바꾸는 방법: `lombok.config`에서 `lombok.log.fieldIsStatic = [true | false] (default: true)` 옵션 조정
* jcabi-log
  * http://www.yegor256.com/2014/05/23/avoid-java-static-logger.html
  * http://log.jcabi.com/
  * https://github.com/jcabi/jcabi-log
  * slf4j static wrapper
  * `private static final Logger logger = LoggerFactory.getLogger()` 를 생략시켜주는 래퍼.
* 스프링에서 로거를 `@Autowired`하자는 지라 논의: https://jira.spring.io/browse/SPR-4431


# 스프링을 돕는 도구들


## EasyMock : RESTful API Mock 서버

* https://blog.outsider.ne.kr/991


## Unitils

* 유닛, 통합테스트 도구
* http://www.unitils.org/summary.html


## JPA (+ Hibernate) (TODO)

* http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation


## Travis CI

* `permission denied (gradlew)`로 빌드 실패하는 경우
  * chmod로 직접 권한 수정
    * `git update-index --chmod=+x gradlew` -> 권한 실행 가능하게 수정
    * `git commit` -> 커밋해야 효력있음
    * `git ls-tree HEAD` -> 권한 확인
  * `.travis.yml`에 옵션을 줘서 자연스럽게 해결

```yml
before_install:
 - chmod +x gradlew
```

* https://stackoverflow.com/questions/33820638/travis-yml-gradlew-permission-denied


# Eclipse

## 마크 (JDT Icons)

http://help.eclipse.org/mars/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fref-icons.htm
공식 문서로 모든 아이콘이 정리되어 있으므로 이후에도 필요할 때 여기를 참고

### 클래스에

* 파랑 역삼각형: package visible class
* 빨강 사각형: private class
* 노랑 동그라미: protected class
* 아무 마크 없음: public class

### 메소드 아이콘에

* 파랑 역삼각형: default method
* 빨강 사각형: private method
* 노랑 동그라미: protected method
* 초록 동그라미: public method

### 필드에

* 파랑 역삼각형: default field
* 빨강 사각형: private field
* 노랑 동그라미: protected field
* 초록 동그라미: public field


## Eclipse

### Oxygen 버그

`organize imports` 단축키(`ctrl+shift+O`)가 먹지 않는다.

* 단축키를 override하는 `Go To Symbol in File` 단축키 바인드를 해제하고 재시작
* https://github.com/spring-projects/spring-ide/issues/160
* https://stackoverflow.com/questions/45256038/eclipse-organize-imports-shortcut-ctrlshifto-is-not-working

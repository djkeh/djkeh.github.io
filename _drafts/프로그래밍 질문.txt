C언어, 자료구조, 어셈블리, C++, 객체지향, 하드웨어, 네트워크, OS, 스레드 프로그래밍, 분산처리, DB, 보안 등등  이 모든게 다 포함되어 있습니다.

"멀티프로세스는 무엇인가"
 - 프로그램 : 보조기억장치에 저장된 실행파일
 - 프로세스 : 프로그램을 메모리에 올린 것 (즉 실행 중인 프로그램)
 - 싱글 프로세스 -> cpu가 단 하나의 프로세스만을 처리
 - 멀티 프로세스 -> cpu가 여러 개의 프로세스를 병렬(가상)처리 가능

 
"스레드와 프로세스간의 차이는 무엇인가"
 - 프로세스는 실행 중인 프로그램
 - 스레드는 프로세스 내부의 실제 프로그램 실행 흐름 단위
 - 프로세스는 독립적인 메모리 공간을 가지므로 프로세스 간 메모리 공유가 없음 -> 멀티 프로세스
 - 멀티 프로세스를 위해 프로세스간 처리 순서를 배열하는 것이 스케쥴링 -> OS의 핵심 기능


"세마포어와 뮤텍스를 설명해보라, 차이는 무엇인가"

 
"멀티 스레드를 너무 많이 만들면 발생하는 문제는? 해결 방법은?"
 - 정해진 수의 일을 너무 많은 쓰레드에 나눠주면 한 쓰레드가 하는일이 너무 작은데 비해 쓰레드를 시작하고 종료하는데 많은 오버헤드 발생
 - 유한한 하드웨어 자원을 공유하면서 추가적인 오버헤드를 초래
  - os가 라운드 로빈 스케쥴링으로 소프트웨어 스레드 작업을 타임 슬라이스해줄 때 발생하는 오버헤드
   1. 쓰레드의 레지스터 상태를 저장 / 복구
   2. 쓰레드 캐시 상태: 캐시 메모리는 주 메모리보다 10~100배 빠름. 캐시가 차면, LRU(least recently used) 데이터를 골라 캐시 삭제한다면, 보통 이전 타임 슬라이스의 데이터가 선택됨 -> 쓰레드가 서로의 캐시를 삭제(차지하려고)
   3. 가상 메모리 쓰레싱
   4. convoying: lock 하나에 여러 소프트웨어 쓰레드가 산더미처럼 쌓이는 현상
 - 하드웨어 쓰레드 vs. 소프트웨어 쓰레드
  - 하드웨어 쓰레드: 1개의 물리 코어가 지원하는 실제 물리 자원
   - 보통 1코어 1쓰레드
   - 인텔 하이퍼쓰레딩: 1코어 2쓰레드
   - 8코어가 코어 당 8개 하드웨어 쓰레드를 지원할 경우 총 지원 쓰레드 개수는 64개
   - 이를 소프트웨어 쓰레드가 넘지 않을 경우 이론적으로 스케쥴링을 통한 컨텍스트 스위칭이 없음
  - 소프트웨어 쓰레드: 프로그램이 만든 것
 - 해결방법: 테스트, 측정, 적절한 쓰레드 설정
  - 실행 가능한 쓰레드 개수를 하드웨어 쓰레드 개수에 맞추어 제한하기
  - 가능하다면 외부 캐시(outer-level cache)의 개수에 맞추어 제한하기
  - 쓰레드 개수를 하드 코딩하지 말고 튜닝 매개변수로 남겨두기
  - 조직화 원칙의 응용: 입출력 쓰레드와 계산 쓰레드 분리
   - 계산 쓰레드: 프로세스 자원에 맞추기
   - IO 쓰레드: 대부분의 시간을 외부 이벤트에 대기하므로 많아도 문제 없음
  - 유용한 기존 프로그래밍 기법을 활용
   - OpenMP
   - 쓰레드 풀
 - http://www.codeguru.com/cpp/sample_chapter/article.php/c13533/Why-Too-Many-Threads-Hurts-Performance-and-What-to-do-About-It.htm
 - https://andromedarabbit.net/%EB%A9%80%ED%8B%B0%EC%BD%94%EC%96%B4-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%97%90%EC%84%9C-%ED%9D%94%ED%9E%88-%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94-%EB%AC%B8%EC%A0%9C-1%EB%B6%80/

 
"스레드 구현은 어떻게 이루어지나?"


"레이스 컨디션과 해결방안은?"
 - 다중 프로그래밍 시스템이나 다중 처리기 시스템에서 두 명령어가 동시에 같은 기억 장소를 액세스할 때 그들 사이의 경쟁에 의해 수행 결과를 예측할 수 없게 되는 것. 이와 같은 현상은 바람직하지 않으므로 운영 체제는 이것을 해소할 수 있어야 한다.
 - critical region(critical section)으로 다른 프로세스가 접근하는 동안 다른 프로세스가 메모리에 접근치 못하도록 막아 순차적으로 문제를 풀어나간다.


"객체와 클래스의 차이는?"
 - 클래스는 정의부, 객체는 선언부
 - 클래스는 타입, 객체는 변수
 - 클래스는 객체의 추상화, 객체는 구체적으로 실체가 있는 것
 - 클래스 : 사람, 객체 : 홍길동

 
"struct{ uint8_t a, uint32_t b}; 의 실제 메모리 크기는?"


"static 변수와 stack 변수의 차이점은?"


"라운도 로빈과 해싱 스케쥴링의 장단점은?"


"가상 메모리가 왜 필요하고 어떻게 구현하면 좋을까"


"1백 억 개의 키 밸류를 랜덤시간에 탐색하기 위한 가장 빠른 알고리즘을 설계, 코딩해봐라."


"OSI 7 레이어 중 TCP/IP는 어디에서 어떻게 구현되나?"


"TCP보다 UDP 가 빠른 이유는?"
 - TCP의 여러가지 기능이 빠져있는 경량 프로토콜이기 때문
 - TCP의 중요 기능
  - connection oriented: 통신 전 연결을 분명하게 맺는 방식
  - reliable transfer: 통신 데이터의 신뢰성을 보장
   - error control: 실패 검사와 복구(재전송)
   - flow control: 네트워크 인터페이스 수신단에 유입되는 패킷량의 조절. 수신 패킷이 유실되지 않음을 보장한다. 버퍼링 개념
   - congestion control: 네트워크에 던지는 패킷량의 조절

"다익스트라 알고리즘을 설명해 봐라"

"피보나치 수열을 재귀로 짜보고 이를 for문으로 바꿔보아라"

"Java가 C보다 느린 이유는? 빠르게 할 순 없나"
 - 가상머신이 개입하여 코드 -> 바이트코드 -> 가상머신이 인터프리트 -> 기계어 과정을 거침
 - 컴파일러와 인터프리터의 차이 : 줄단위 번역 여부, 목적 프로그램 생성 여부, 속도
 - 컴파일러를 쓰는 c는 자바보다 빠를 수 밖에
 - 개선방법 : ?

"공개키와 대칭키"
 - 대칭키(비밀키)(symmetric) : 송수신자가 같은 암호 사
   Ks(Ks(m)) = m 이 성립해야 함
   크게 stream cipher(한 번에 한 비트를 암호화), block cipher(한 번에 여러 비트를 암호화)로 나눔
   stream cipher ex : RC4 -> 802.11 의 WEP 에서 사용되는 방식, SSL에서 사용 가능
   block cipher ex : CBC(cipher block chaining) : 이전 블록이 다음 블록 암호화에 꼬리를 물고 연관을 가짐, 첫 블록은 initialization vector(랜덤 블록) 으로 시작
   DES : data encryption standard(56bit 대칭키, CBC 원리), AES -> advanced DES(128~256 대칭키)
 - 공개키 : 송수신자가 다른 암호 사용, 공개(암호화)키는 모두 알 수 있지만 개인(복호화)키는 수신자만 안다
   Kpd(Kpe(m)) = m 이 성립해야 함
   Kpe 로 Kpd 를 연산 추정 불가해야 함
   RSA : rivest, shamir, adelson 알고리즘. 공개키 핵심 알고리즘
   나머지(mod) 연산이 핵심 아이디어, c = m^e mod n, m = c^d mod n
   e는 짧은데 d는 엄청나게 커서 알기 어려움
   연산 순서를 바꿔도 똑같이 동작
   강하지만 DES 보다 100배 느리다
   sesseion keys : 공개키 + 대칭키 => Ks를 RSA로 암호화하여 교환, 이후 통신은 Ks로. Ks가 공개키로 보안되어 결국 Ks를 뚫기 어려워짐


"AES 방식과 WPK2 방식의 차이점은? "
 - wpk2 는 wpa2 의 오타같다
 - AES는 암호 방식, WPA2는 보안 표준
 - 보안 표준이 암호 방식을 사용한다. 즉 포함하는 관계
 - 무선공유기 보안은 인증과 보안 표준이 사용하는 암호 알고리즘으로 구성
 - 인증 : wep(취약), wpa-psk, wpa2psk (psk : pre-shared key. 사용 전 양쪽이 사전 공유한 공개키)
 - 암호 : tkip(wep 개선), aes(가장 안전)
 - wpa : wifi protected access. wep 취약점이 드러난 후 대안. wpa 는 tkip, wpa2는 aes 사용

"OS가 뭐야? OS가 하는 일은?"
 - 하드웨어와 유저 간의 인터페이스
 - 항상 실행 중인 프로그램
 - 자원 관리(리소스 매니저)
 - 서비스 제공 (확장 머신이나 가상 머신)
 - 레이어링 : 프로그램과 하드웨어 사이, 멀티유저 OS의 경우 유저 사이, 멀티태스킹 OD의 경우 프로그램 사이
 - 프로세스 관리
 - cpu 스케쥴링 : 멀티프로세스
 - 파일 시스템
 - 네트워킹
 - 하드웨어 시스템 가상화 -> 무한의 메모리와 cpu 타임 인식 -> 프로그래밍이 더 용이해짐


"바이너리서치 구현하라"
 - recursive와 iterative 방법이 있다
 - recursive : return binarySearch(array, data, first, last);
 - iterative : while(low <= high) { }로 구현

"퀵소트 구현하라"


"raid 쫙 불러봐라"
 - raid 0 : striping, 데이터 분산 -> 빠른 입출력, 가장 빠르고 안정성 떨어짐
 - raid 1 : mirroring, 데이터 복제 -> 복구가능, 안정성, 용량 감소 => 다중 사용자 시스템에서 최고 성능과 최고의 고장대비 능력 발휘
 - raid 3 : striping + parity 하드 (즉 총 3개) => 입출력이 겹치지 않음, 대형 레코드가 사용되는 업무에서 단일 사용자 시스템에 적합
 - raid 5 : 회전식 parity array (총 3~5개 디스크 어레이) => 모든 읽기/쓰기가 중첩 가능, 성능이 그리 중요하지 않고 쓰기 작업이 많지 않은 다중 사용자 시스템에 적합
 - raid 10 : 각 스트라이프가  raid 1 어레이 => raid 1 보다 높은 성능, 가격이 비쌈

"공개키 기반 구조(pki)에서 최상위 인증기관(ca)은?"
 - root ca

"네트워크 보안이란?"
 - confidentiality : encrypt/decrypt -> 송신자 수신자만이 이해 가능
 - authentication : 송수신자가 서로 인증 가능
 - message integrity : 메시지는 중간에 바뀌지 않음
 - access and availability : 사용자가 사용가능한 서비스

"보안 침해 유형"
 - eavesdrop : 메시지 가로채기
 - 가짜 메시지 송신
 - impersonation : 패킷 근원지 주소 바꾸기
 - hijacking : 송수신자 한 쪽 포지션을 가로채는 것
 - denial of service : 서비스 가로막기 (물량공격으로)

